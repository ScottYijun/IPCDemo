
我们以前学的命令 cat  file | grep  "abc"  > file2
在我看来 我们把cat 读取file中的内容读到内存在通过过滤命令grep 过滤出包含"abc"的记录 再输出重定向到文件file2
在这个过程中 我们把cat  file | grep  "abc"的输出内容作为 > 的输入内容。

如果两个进程要进行通信的话，就可以用这种管道来进行通信了，并且我们可以知道这条坚线是没有名字的，所以我们把这种通信方式称之为匿名管道。



在Linux系统中，管道通信可以通过使用系统调用来实现。


pipe函数可用于创建一个管道，以实现进程间的通信。

pipe函数的定义如下：

#include<unistd.h>
int pipe(int fd[2]);

一、无名管道：
pipe函数定义中的fd参数是一个大小为2的一个数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入fd参数指向的数组。失败时返回 -1并设置errno。

通过pipe函数创建的这两个文件描述符 fd[0] 和 fd[1] 分别构成管道的两端，往 fd[1] 写入的数据可以从 fd[0] 读出。并且 fd[1] 一端只能进行写操作，fd[0] 一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。

默认情况下，这一对文件描述符都是阻塞的。此时，如果我们用read系统调用来读取一个空的管道，则read将被阻塞，知道管道内有数据可读；如果我们用write系统调用往一个满的管道中写数据，则write也将被阻塞，直到管道有足够的空闲空间可用(read读取数据后管道中将清除读走的数据)。当然，用户可自行将 fd[0] 和 fd[1] 设置为非阻塞的。

如果管道的写端文件描述符 fd[1] 的引用计数减少至0，即没有任何进程需要往管道中写入数据，则对该管道的读端文件描述符 fd[0] 的read操作将返回0(管道内不存在数据的情况)，即读到了文件结束标记(EOF，End Of File)；反之，如果管道的读端文件描述符 fd[0] 的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符 fd[1] 的write操作将失败，并引发SIGPIPE信号(往读端被关闭的管道或socket连接中写数据)。

管道内部传输的数据是字节流，这和TCP字节流的概念相同。但它们又存在细微的差别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方接受窗口的大小和本端的拥塞窗口的大小。而管道的话本身拥有一个容量限制，它规定如果管道的写端应用程序不将管道中数据读走的话，该管道最多还能被写入多少字节的数据。管道容量的大小默认是65536字节。我们也可以使用fcntl函数来修改管道容量。


管道，顾名思义，当我们希望将两个进程的数据连接起来的时候就可以使用它，从而将一个进程的输出数据作为另一个进程的输入数据达到

通信交流的目的。
但值得我们注意的是：管道它有自身的特点。
 （1）管道通信是单向的，并且遵守先进先出的原则，即先写入的数据先读出。
 （2）管道是一个无结构，无固定大小的字节流。
 （3） 管道把一个进程的标准输出和另一个进程的标准输入连接在一起。数据读出后就意味着从管道中移走了，消失了。其它的进程都不能   

           再读到这些数据。就像我们平常见到的管子水流走了就没有了。 这点很重要！！
  （4） pipe这种管道用于两个有亲缘关系的进程之间。eg:父子进程......


原文链接：https://blog.csdn.net/ta893115871/article/details/7478779




