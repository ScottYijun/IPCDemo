
四、共享内存
为最为高效的进程间通信方式
进程直接读写内存，不需要任何数据的拷贝
a.为了在多个进程间交换信息，内核专门留出了一块内存区。
b.由需要访问的进程将其映射到自己私有地址空间。
c.进程直接读写这一内存区而不需要进行数据的拷贝，提高了效率。

特别提醒：共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之间，
并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问。
例如信号量。

共享内存编程步骤：
1.创建共享内存
函数shmget()
从内存中获得一段共享内存区域

2.映射共享内存
把这段创建的共享内存映射到具体的进程空间中
函数shmat()

3.使用这段共享内存
可以使用不带缓冲的IO读写命令对其进行操作

4.撤销映射操作：函数shmdt()

5.删除共享内存：函数shctl();

共享内存的使用
1.shmget函数
该函数用来创建共享内存，它的原型为
int shmget(key_t key, size_t size, int shmflg);
第一个参数，key_t标示符（非0整数)，它有效地为共享内存段命名,shmget函数成功时返回一个与key相关的共享内存标识符（非负整数），
用于后续的共享内存函数。调用失败返回-1.
第二个参数，size以字节为单位指定需要共享的内存容量
第二个参数，shmflg是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的庆，可以与IPC_CREAT做或操作。
共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者拥有的进程向共享内存读取和写入数据，
同时其他用户创建的进程只能读取共享内存。

2.shmat函数
第一次创建完共享内存时，它还不能被任何进程访问，shmat函数的作用就是用来启动对该共享内存的访问，
并把共享内存映射到当前进程的地址空间。它的原型如下：
void *shmat(int shm_id, const void *shm_addr, int shmflg);
int shmdt(const void *shmaddr);
第一个参数，shm_id是由shmget函数返回的共享内存标识。
第二个参数，shm_addr指定共享内存映射到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。
第三个参数，shm_flg是一组标志位，通常为0.
调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.

3.shmdt函数
该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。它的原型如下：
void *shmat(int shmid, const void *shmaddr, int shmflg);
参数shmaddr是shmat函数返回的地址指针，调用成功时返回0,失败时返回-1.


4.shmctl函数
与消息队列的msgctl()和信号量的semctl()函数一样，用来控制工享内存，它的原型如下：
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
第一个参数，shmid是shmget函灵敏返回的共享内存标识符。
第二个参数，cmd是要采取的操作，它可以取下面的三个值：
IPC_STAT:把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。
IPC_SET:如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值
IPC_RMID：删除共享内存段
第二个参数，buf是一个结构体指针，它指向共享内存模式和访问权限的结构。





分析：
1、程序shmread创建共享内存，然后将它连接到自己的地址空间。在共享内存的开始处使用了一个结构struct_use_st。该结构中有个标志written，当共享内存中有其他进程向它写入数据时，共享内存中的written被设置为0，程序等待。当它不为0时，表示没有进程对共享内存写入数据，程序就从共享内存中读取数据并输出，然后重置设置共享内存中的written为0，即让其可被shmwrite进程写入数据。

2、程序shmwrite取得共享内存并连接到自己的地址空间中。检查共享内存中的written，是否为0，若不是，表示共享内存中的数据还没有被完，则等待其他进程读取完成，并提示用户等待。若共享内存的written为0，表示没有其他进程对共享内存进行读取，则提示用户输入文本，并再次设置共享内存中的written为1，表示写完成，其他进程可对共享内存进行读操作。


关于前面的例子的安全性讨论
这个程序是不安全的，当有多个程序同时向共享内存中读写数据时，问题就会出现。可能你会认为，可以改变一下written的使用方式，例如，只有当written为0时进程才可以向共享内存写入数据，而当一个进程只有在written不为0时才能对其进行读取，同时把written进行加1操作，读取完后进行减1操作。这就有点像文件锁中的读写锁的功能。咋看之下，它似乎能行得通。但是这都不是原子操作，所以这种做法是行不能的。试想当written为0时，如果有两个进程同时访问共享内存，它们就会发现written为0，于是两个进程都对其进行写操作，显然不行。当written为1时，有两个进程同时对共享内存进行读操作时也是如些，当这两个进程都读取完是，written就变成了-1.

要想让程序安全地执行，就要有一种进程同步的进制，保证在进入临界区的操作是原子操作。例如，可以使用前面所讲的信号量来进行进程的同步。因为信号量的操作都是原子性的。

五、使用共享内存的优缺点
1、优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。

2、缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。








https://www.cnblogs.com/forstudy/archive/2012/03/26/2413724.html
https://blog.csdn.net/ljianhui/article/details/10253345




