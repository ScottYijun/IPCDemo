
五、信号量
1.什么时信号量
为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，
在作一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。
而信号量就可以提供这样的一种访问机制，让一个临界区同一时间吸一个线程在访问它，
也就是说信号量是用来协调进程对共享资源的访问的。

信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P（信号变量））和发送（即V（信号变量））信息操作。
最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。
这里主要讨论二制信号量。

2.信号量的工作原理
由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv)，他们的行为是这样的：
P(sv): 如果sv的值大于零，就给它减1;如果它的值为零，就挂起该进程的执行
V(sv): 如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.

举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，
并可以进入临界区，使用sv减1.而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0,
它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。


3.Linux的信号量机制
Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将对这些函数进行介绍，
但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件sys/sem.h中。

1.semget函数
它的作用是创建一个新信号亘或取得一个已有信号量，原型为：
int semget(key_t key, int nsems, int semflg);
第一个参数key是整数值(唯一非零)，不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，
程序对所有信号量的访问都是间接的，程序先通过调用semget函数并提供一个键，再由系统生成一个相应的信号标识符
（semget）函数的返回值，只有semget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。
如果多个程序使用相同的key值，key将负责协调工作。

第二个参数nsems指定需要的信号量数目，它的值几乎总是1.

第三个参数semflg是一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，
即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT||IPC_EXCL则可以创建一个新的，唯一的信号量，
如果信号量已存在，返回一个错误。

semget函数成功返回一个相应信号标识符（非零），失败返回-1.
EACCES：没有访问该信号量集的权限
EEXIST：信号量集已经存在，无法创建
EINVAL：参数nsems的值小于0或者大于该信号量集的限制；或者是该key关联的信号量集已存在，并且nsems大于该信号量集的信号量数
ENOENT：信号量集不存在，同时没有使用IPC_CREAT
ENOMEM ：没有足够的内存创建新的信号量集
ENOSPC：超出系统限制



2.semop函数
它的作用是改变信号量的值，原型为：
int semop(int semid, struct sembuf *sops, size_t nsops);
第一个参数semid是一个通过semget函数返回的一个信号量标识符
第二个参数sops是一个struct sembuf结构体类型的指针，
结构sembuf来说明所要执行的操作，其定义如下：
struct sembuf{
　　unsigned short sem_num;
　　short sem_op;
　　short sem_flg;
}
sem_num是相对应的信号量集中的某一个资源，所以其值是一个从0到相应的信号量集的资源总数(ipc_perm.sem_nsems)之间的整数。
除非使用一组讯号了，否则它的取址一般为0.
sem_op的值是一个整数，是信号量在一次操作中需要改变的数值（可以是非1的数值）。通常只会用到两个值：1---》P操作，-1---》V操作。
sem_flg说明函数semop的行为。通常被设置为SEM_UNDO。它将使得操作系统跟着当前进程对这个信号量的修改情况，
如果这个进程在没有释放该信号量的情况下终止，操作系统将自动释放该进程持有的信号量。

第三个参数nsops标明了参数sops所指向数组中的元素的个数。

注意：
semop调用的一切动作都是一次性完成的，这是为了避免出现因使用多个信号量而可能发生的况争现象。
int semctl(int semid, int semnum, int cmd, ...);

参数解释：
第一个参数semid是由semget返回的信号量标识符。
第二个参数semnum创建的信号集中的信号量的个数
第三个参数cmd表示将要采取的动作。最常用的两个值如下：
SETVAL：用来把信号量初始化为一个已知的值。这个值通过union semun中的val成员设置。
		其作用是在信号量第一次使用之前对它进行设置。
IPC_RMID：用于删除一个无需继续使用的信号量标志符。
如果有第四个参数，它通常是一个unio semum结构体，定义如下：
union semun{
    int val;
    struct semid_ds *buf;
    unsigned short *arry;
};

前两个参数与前面一个函数中的一样，command通常是下面两个值中的其中一个
SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。
IPC_RMID：用于删除一个已经无需继续使用的信号量标识符。


返回值：
如果成功，则为一个正数。
如果失败，则为-1
errno=EACCESS(权限不够)
　　EFAULT(arg指向的地址无效)
　　EIDRM(信号量集已经删除)
　　EINVAL(信号量集不存在，或者semid无效)
　　EPERM(EUID没有cmd的权利)
　　ERANGE(信号量值超出范围) 



4､进程使用信号量通信
下面使用一个例子来说明进程间如何使用信号量通信，这个例子是两个相同的程序同时向屏幕输出数据，
我们可以看到如何使用信号量来使两个进程协调工作，使同一时间只有一个进程可以向屏幕输出数据。
注意，如果程序是第一次被调用（为了区分，第一次调用程序时带一个要输出到屏幕中的字符作为一个为一个参数😯）
则需要调用set_semvalue函数初始化信号并将message字符设置为传递给程序的参数的第一个字符，
同时第一个启动的进程还负责信号量的删除工作。如果不删除信号量，它将继续在系统中存在，即使程序已经退出。
它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。

在main函数中调用semget来创建珍上信号量，该函数将返回一个信号标识符，保存于全局变量sem_id中，
然后以后的函数就使用这个标识符来访问信号量。
代码如semaphore.c 所示。



运行环境
MacOS 10.14.6
Ubuntu2016.4









https://blog.csdn.net/xiajun07061225/article/details/8475738
https://blog.csdn.net/ljianhui/article/details/10243617




